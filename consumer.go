package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"

	_ "github.com/lib/pq"
	"github.com/segmentio/kafka-go"
	"github.com/segmentio/kafka-go/sasl/plain"
)

var (
	kafkaBrokers []string
	dialer       *kafka.Dialer
	db           *sql.DB
)

// CVEData represents the structure of CVE data with specific field order
type CVEData struct {
	CVEID   string  `json:"cveId"`
	Version float64 `json:"version"`
}

func main() {
	kafkaBrokers = []string{
		os.Getenv("KAFKA_BROKER1"),
		os.Getenv("KAFKA_BROKER2"),
		os.Getenv("KAFKA_BROKER3"),
	}

	kafkaTopic := os.Getenv("KAFKA_TOPIC")
	kafkaUsername := os.Getenv("KAFKA_USERNAME")
	kafkaPassword := os.Getenv("KAFKA_PASSWORD")
	dbURL := os.Getenv("DB_URL")

	if kafkaTopic == "" || kafkaUsername == "" || kafkaPassword == "" || dbURL == "" {
		log.Fatal("One or more environment variables are not set")
	}

	dialer = &kafka.Dialer{
		SASLMechanism: plain.Mechanism{
			Username: kafkaUsername,
			Password: kafkaPassword,
		},
	}

	var err error
	db, err = initializePostgresDB(dbURL)
	if err != nil {
		log.Fatalf("Error initializing PostgreSQL DB: %v", err)
	}
	defer db.Close()

	readers := createKafkaReaders(kafkaBrokers, kafkaTopic, dialer)

	defer func() {
		for _, reader := range readers {
			if err := reader.Close(); err != nil {
				log.Printf("Error closing Kafka reader: %v", err)
			}
		}
	}()

	ctx := context.Background()

	for _, reader := range readers {
		go consumeMessages(ctx, reader, db)
	}

	http.HandleFunc("/readiness", readinessHandler)
	http.HandleFunc("/healthz", livenessHandler)
	log.Println("Starting server on :8080...")
	if err := http.ListenAndServe(":8080", nil); err != nil {
		log.Fatalf("Server failed: %v", err)
	}

	select {}
}

func livenessHandler(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, "OK") }

func initializePostgresDB(dbURL string) (*sql.DB, error) {
	db, err := sql.Open("postgres", dbURL)
	if err != nil {
		return nil, fmt.Errorf("error connecting to PostgreSQL: %v", err)
	}

	err = db.Ping()
	if err != nil {
		db.Close()
		return nil, fmt.Errorf("error pinging PostgreSQL: %v", err)
	}

	log.Println("Connected to PostgreSQL database.")
	return db, nil
}

func createKafkaReaders(brokers []string, topic string, dialer *kafka.Dialer) []*kafka.Reader {
	readers := make([]*kafka.Reader, len(brokers))
	for i, broker := range brokers {
		readers[i] = kafka.NewReader(kafka.ReaderConfig{
			Brokers:        []string{broker},
			Topic:          topic,
			GroupID:        fmt.Sprintf("group%d", i+1),
			Dialer:         dialer,
			MinBytes:       10e3, // 10KB
			MaxBytes:       10e6, // 10MB
			MaxWait:        1e9,  // 1 second
			CommitInterval: 500 * time.Millisecond,
		})
	}
	return readers
}

func consumeMessages(ctx context.Context, reader *kafka.Reader, db *sql.DB) {
	for {
		log.Printf("Consumer group %s attempting to read message from Kafka...", reader.Config().GroupID)
		msg, err := reader.ReadMessage(ctx)
		if err != nil {
			log.Printf("Error reading message from Kafka: %v", err)
			continue
		}

		if len(msg.Value) == 0 {
			log.Println("Received nil message from Kafka")
			continue
		}

		var cveData CVEData
		if err := json.Unmarshal(msg.Value, &cveData); err != nil {
			log.Printf("Error unmarshalling JSON from Kafka message: %v", err)
			continue
		}

		if err := storeInPostgreSQL(db, cveData.CVEID, cveData.Version, msg.Value); err != nil {
			log.Printf("Failed to store CVE data in PostgreSQL: %v", err)
			continue
		}

		log.Printf("CVE data with ID %s stored in PostgreSQL successfully", cveData.CVEID)
	}
}

func storeInPostgreSQL(db *sql.DB, cveID string, version float64, originalJSON []byte) error {
	_, err := db.Exec("INSERT INTO cve.cves (cve_id, version, cve_data) VALUES ($1, $2, $3::jsonb)", cveID, version, originalJSON)
	if err != nil {
		return fmt.Errorf("failed to insert CVE data into PostgreSQL: %v", err)
	}
	return nil
}

func checkKafka() error {
	for _, broker := range kafkaBrokers {
		conn, err := dialer.DialContext(context.Background(), "tcp", broker)
		if err != nil {
			return fmt.Errorf("unable to connect to Kafka broker %s: %v", broker, err)
		}
		conn.Close()
	}

	reader := kafka.NewReader(kafka.ReaderConfig{
		Brokers: kafkaBrokers,
		Topic:   os.Getenv("KAFKA_TOPIC"),
		Dialer:  dialer,
	})
	defer reader.Close()

	_, err := reader.ReadLag(context.Background())
	if err != nil {
		return fmt.Errorf("Kafka topic %s does not exist or is not reachable: %v", os.Getenv("KAFKA_TOPIC"), err)
	}

	return nil
}

func checkDatabase() error {
	if err := db.Ping(); err != nil {
		return fmt.Errorf("unable to connect to the database: %v", err)
	}
	return nil
}

func readinessHandler(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	if err := checkKafka(); err != nil {
		http.Error(w, fmt.Sprintf("Kafka not ready: %v", err), http.StatusServiceUnavailable)
		return
	}

	if err := checkDatabase(); err != nil {
		http.Error(w, fmt.Sprintf("Database not ready: %v", err), http.StatusServiceUnavailable)
		return
	}

	select {
	case <-ctx.Done():
		http.Error(w, "Readiness check timed out", http.StatusGatewayTimeout)
	default:
		fmt.Fprintln(w, "OK")
	}

}
